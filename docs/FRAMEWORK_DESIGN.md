# Cap Framework 设计文档

> 本文档仅阐述框架的规范、约束和设计思想，不涉及工具类等实现细节。  
> 目标读者：使用 Cap Framework 开发应用的工程师及框架维护者。

---

## 第一部分：核心设计理念

### Bean 生命周期的完整规范视图

Cap Framework 将 Bean 的生命周期划分为四个不可重叠的阶段：

| 阶段 | 职责 |
|------|------|
| **注册阶段** | 扫描 `@Capper` 注解，解析并校验 `BeanDefinition`，将元数据写入容器。此阶段不涉及任何类实例化。 |
| **实例化阶段** | 依据 `BeanDefinition` 中的实例化策略（构造函数或工厂方法）创建 Bean 实例。依赖注入在此完成。 |
| **初始化阶段** | 回调 `BeanLifecycle.afterPropertiesSet()`，执行 `afterInitialization` 拦截器链（如 AOP 代理创建）。 |
| **销毁阶段** | 按注册逆序回调 `BeanLifecycle.destroy()`，释放资源。仅对单例且实现了 `BeanLifecycle` 的 Bean 有效。 |

### 为什么采用分阶段设计？

分阶段设计保证了各阶段职责的单一性与可预期性。注册阶段结束后，元数据是完整且一致的；实例化阶段只负责创建对象，不关心初始化语义。每个阶段的行为都是不可逆的——Bean 一旦注册，其元数据不可更改；Bean 一旦初始化，则视为可用。这使框架的行为对用户而言是透明和可推断的。

### 实例化策略的语义设计

**构造函数实例化**：表达"Bean 本身知道如何创建自己"——依赖通过构造函数参数声明，框架按参数顺序注入。适用于大多数普通 Bean。

**工厂方法实例化**：表达"需要由外部对象来决定如何创建 Bean"——适用于第三方类、需要复杂初始化逻辑、或非静态内部类等无法直接用构造函数实例化的场景。`factoryBeanName` 和 `factoryMethodName` 共同构成完整的实例化描述，两者不可分离。

### 参数注入规范的设计意图

参数注入采用优先级模型，而非单一策略，目的是在**显式意图**与**开发效率**之间取得平衡：显式 `@Inject(beanName="...")` 优先，保证开发者的意图不被框架覆盖；在未显式指定时，框架依据类型名称约定自动推导，遵循"约定优于配置"原则，减少样板代码。

---

## 第二部分：接口规范与约束

### BeanNamesResolver 接口规范

`BeanNamesResolver` 将名称解析职责分离为三个独立方法，各自服务于不同的解析场景。

#### `resolveClass(Class<?> clazz)`

用途：解析标注了 `@Capper` 的类，返回 Bean 名称数组。数组第一个元素为主名称，其余为别名。若注解未指定名称，则以类的简单名称首字母小写作为默认名称。

与 `resolveMethod()` 分离的原因：类代表的是一个**持久注册的 Bean 类型**，其命名来源于类型本身；方法则代表**按需生产的 Bean 实例**，其命名来源于方法语义。两者的推导规则虽然相似，但语义上属于不同的声明维度。

#### `resolveMethod(Method method)`

用途：解析标注了 `@Capper` 的工厂方法，返回 Bean 名称数组。默认名称为方法名首字母小写。方法名通常能直接表达其产出物的语义（如 `createDataSource()` → `dataSource`），因此方法名作为默认名称具有自描述性。

方法名称可配置性的意义：允许工厂方法名称与产出 Bean 名称解耦，同一工厂类中不同方法可生产同类型的不同 Bean（按名称区分），通过 `@Capper(names="...")` 显式控制。

#### `resolveParameter(Constructor<?>)` 和 `resolveParameter(Method)`

用途：解析构造函数或工厂方法的所有参数，返回与参数个数相同的 Bean 名称数组，按参数顺序排列。

**参数推导三级优先级：**

1. **`@Inject(beanName="...")`**：参数上若存在 `@Inject` 注解且 `beanName` 非空，则直接使用指定名称。这是最高优先级，体现"显式优于隐式"原则。
2. **参数类型简单名称首字母小写**（如 `MyService` → `myService`）：当遵循框架的 Bean 命名约定时，参数类型名称与 Bean 名称天然对应，无需额外配置。
3. **无法推导时抛出 `BeanDefinitionException`**：明确指出哪个参数无法解析，包含所属方法/构造函数名称和参数索引，辅助开发者定位问题。

**三个接口的职责边界：** 类与方法的解析关注"这个 Bean 叫什么"，参数解析关注"这个 Bean 依赖什么"。分离后每个方法的职责单一，测试与扩展均更清晰。

---

### BeanDefinition 约束规范

#### `factoryBeanName` 与 `factoryMethodName` 的绑定约束

**约束规则**：`factoryBeanName` 与 `factoryMethodName` 必须**同时为 null** 或**同时非 null**。任何导致两者 null 状态不一致的操作（包括直接构造和 `wither` 方法调用）都会立即抛出 `BeanDefinitionStoreException`。

**原因**：这两个字段共同描述一个完整的工厂实例化策略——"由哪个 Bean（`factoryBeanName`）的哪个方法（`factoryMethodName`）来创建实例"。单独指定任一字段在语义上是不完整的，框架无法据此执行实例化，因此在元数据层面即强制约束，避免将不完整的配置延迟到运行时才发现。

**处理策略**：在 `BeanDefinition` 的紧凑构造函数中立即校验，一旦违反约束即抛出 `BeanDefinitionStoreException`（继承自 `BeanDefinitionException`），异常信息明确指出两个字段的实际值以便排查。

---

### 参数注入规范

#### 三级优先级的完整说明

| 优先级 | 条件 | 推导结果 |
|--------|------|---------|
| 1 | 参数存在 `@Inject` 注解且 `beanName` 非空 | 使用 `@Inject.beanName()` 的值 |
| 2 | 参数类型的简单类名可用 | `decapitalize(paramType.getSimpleName())` |
| 3 | 以上均不满足 | 抛出 `BeanDefinitionException` |

#### `@Inject` 注解的语义

`@Inject` 在参数上表达的是**显式依赖声明**。使用 `@Inject(beanName="...")` 时，开发者明确指定了依赖的 Bean 名称，框架必须尊重这个意图，不允许被类型推导覆盖。这一"显式优于隐式"的原则确保了在同一接口存在多个实现时，开发者能够精确控制注入目标。

---

## 第三部分：框架规范与约束

### 实例化规范

#### 构造函数选择规则

- 若类仅有一个构造函数（含默认无参构造函数），框架直接使用，无需 `@Inject` 标注。
- 若类存在多个构造函数，必须有且仅有一个构造函数标注 `@Inject`，否则在注册阶段抛出 `BeanDefinitionException`。
- 优先使用标注了 `@Inject` 的构造函数；若未标注任何 `@Inject` 且存在多个构造函数，则视为配置错误，立即抛出异常。

#### 工厂方法调用约束

- **非静态工厂方法**：所在类必须可实例化（非接口、非抽象类），框架会先注册工厂类的 `BeanDefinition`，再通过工厂 Bean 实例调用方法。
- **静态工厂方法**：通过 `null` 接收者调用（`method.invoke(null, args)`），无需工厂 Bean 实例。
- 工厂方法的参数解析与构造函数相同，遵循同样的三级优先级规则。

---

### 命名规范

#### `@Capper.names` 属性的语义

- 空数组或全空字符串：使用默认名称（类名/方法名首字母小写）。
- 单个名称：该名称作为唯一 Bean 名称。
- 多个名称：第一个名称为**主名称（规范名）**，其余为**别名**。

#### 别名的使用原则

别名是对同一 Bean 的等价引用，主要用于以下场景：
- 兼容多套命名约定（如 `dataSource` 与 `ds`）
- 提供业务语义更明确的替代名称

别名在任何需要 Bean 名称的地方均可使用（`getBean`、`@Inject(beanName="...")`、`dependsOn` 等）。

#### 名称冲突的处理

同一主名称只能被一个 Bean 定义占用。若尝试注册已存在名称的 `BeanDefinition`，容器将抛出 `BeanDefinitionStoreException`。框架不支持 Bean 定义覆盖，若需替换，应先移除旧定义。

---

### 异常处理规范

#### 注册时立即抛出的错误

以下错误属于元数据一致性问题，在注册阶段即可检测，应立即抛出异常，避免延迟到运行时：

- `BeanDefinition` 字段约束违反（如 `factoryBeanName` / `factoryMethodName` 状态不一致）
- Bean 名称重复注册
- 多个构造函数且无 `@Inject` 标注
- 非静态工厂方法所在类不可实例化
- 参数类型无法推导 Bean 名称

#### 延迟到运行时的错误

以下错误无法在注册阶段检测（取决于运行时状态），延迟到首次 `getBean` 时抛出：

- 依赖的 Bean 不存在（`NoSuchBeanDefinitionException`）
- 实例化过程中的反射异常（`BeanCreationException`）
- 初始化回调执行失败（`BeanInitializationException`）

#### 异常信息规范

所有异常信息应包含：
1. **Bean 名称**：明确标识哪个 Bean 出了问题
2. **错误原因**：描述具体的失败原因（而非泛化的"出错了"）
3. **上下文信息**（可选）：如参数索引、字段值等，帮助快速定位问题

---

## 第四部分：设计权衡分析

### 权衡 1：参数类型表示 — `Class<?>[]` vs `String[]`

**选项 A（`Class<?>[]`）**：在编译期即确定参数类型，类型安全，无需运行时推导。  
**选项 B（`String[]`）**：以 Bean 名称字符串表示参数，支持运行时推导，与 `@Inject` 参数注解协作自然。

**选择：`String[]`**

`BeanDefinition` 中使用 `String[]` 存储参数 Bean 名称，而非 `Class<?>[]`，核心原因在于支持 `@Inject` 参数注解的显式指定能力。若使用 `Class<?>`，则无法表达"注入名为 `primaryDataSource` 的 Bean"这一意图（同类型可能有多个 Bean）。`String[]` 保留了完整的运行时灵活性，使参数注入策略可在框架外部的扫描阶段完成。

**对用户的影响**：开发者在注册 `BeanDefinition` 时需要提供 Bean 名称字符串，框架提供 `BeanNamesResolver` 辅助推导，降低手动编写的负担。

---

### 权衡 2：参数名推导策略 — 完全显式 vs 智能推导

**选项 A（完全显式）**：要求所有参数必须通过 `@Inject(beanName="...")` 显式声明，无隐式推导。  
**选项 B（智能推导）**：根据参数类型名称自动推导 Bean 名称，仅在需要精确控制时才显式声明。

**选择：智能推导（显式优先）**

当项目遵循 Bean 命名约定（类名首字母小写）时，参数类型与 Bean 名称天然对应，无需重复声明。智能推导消除了大量样板代码，提升开发效率。而显式 `@Inject` 作为覆盖机制，保证在同类型多 Bean 的场景下依然可精确控制。

**新约束**：依赖的 Bean 必须遵循命名约定，否则需要显式 `@Inject`。推导失败时框架在注册阶段即报错，不会静默失败。

---

### 权衡 3：内部类支持 — 自动反射创建 vs 禁止直接注册

**选项 A（反射创建）**：框架通过反射自动处理非静态内部类，隐含传入外部类实例。  
**选项 B（禁止 + 工厂方法）**：禁止非静态内部类直接标注 `@Capper`，要求通过工厂方法注册。

**选择：禁止直接注册，使用工厂方法替代**

非静态内部类的构造函数有一个隐含的外部类实例参数（`$this`），这破坏了框架"参数个数 = 依赖个数"的基本假设。自动处理这一隐含参数会使框架逻辑复杂化，且向用户暴露了 Java 实现细节。工厂方法模式语义更清晰，将复杂性交给用户控制，保持框架的简洁性。

**新约束**：非静态内部类无法直接标注 `@Capper`，必须通过外部类的工厂方法生产。

---

### 权衡 4：容器职责边界 — 容器编排整个生命周期 vs 上层编排

**选项 A（容器编排）**：容器直接管理 Bean 从注册到销毁的完整生命周期，业务代码只与容器交互。  
**选项 B（上层编排）**：容器只负责创建和存储，上层（如 `cap-boot`）负责生命周期编排策略。

**选择：上层编排**

将容器职责限定为创建、存储、销毁，而非编排策略，使 `cap-bean` 模块的核心实现无需感知启动流程。上层模块可以选择不同的生命周期策略（如懒加载、预热等），而不必修改容器实现。这一设计体现了**关注点分离**原则，使框架各层可独立演进。

**对用户的影响**：直接使用 `cap-bean` 容器时，生命周期管理需要由调用方负责。使用 `cap-boot` 时，`BootstrapRunner` 机制提供了完整的生命周期管理。

---

### 权衡 5：异常时机 — 所有错误注册时发现 vs 延迟到运行时

**选项 A（全部提前）**：所有可能的错误在注册阶段全部检测并抛出。  
**选项 B（全部延迟）**：所有错误延迟到运行时（首次 `getBean`）时才抛出。

**选择：混合策略**

数据一致性约束（如 `factoryBeanName` / `factoryMethodName` 配对约束、参数名称无法推导）属于元数据层面的错误，在注册阶段即可确定，应立即抛出，防止带着错误配置运行。资源错误（如依赖 Bean 不存在、实例化失败）取决于整个容器的状态，在注册阶段无法完整判断，延迟到运行时是合理的。

**新约束**：延迟错误的存在意味着完整的功能验证需要在运行时进行，推荐在项目启动时进行完整的 Bean 图预加载（warm-up）以提前发现问题。

---

### 权衡 6：参数优先级 — `@Inject` 显式指定优先 vs 类型推导优先

**选项 A（显式优先）**：`@Inject(beanName="...")` 具有最高优先级，覆盖任何推导结果。  
**选项 B（推导优先）**：优先使用类型推导，`@Inject` 作为补充。

**选择：显式优先**

开发者使用 `@Inject(beanName="...")` 时，是在表达明确的依赖意图。框架覆盖这一意图会产生混乱，且难以排查。显式优先确保"写什么就得到什么"，符合最小惊讶原则。在不指定 `beanName` 时，框架才启用类型推导作为默认行为。

**对用户的影响**：开发者可以放心使用 `@Inject` 精确控制注入目标，不必担心被框架的推导逻辑干扰。

---

### 权衡 7：实例化策略设计 — 独立接口 vs 合并到 BeanDefinition

**选项 A（独立接口）**：定义 `InstantiationPolicy` 接口，`BeanDefinition` 持有策略引用。  
**选项 B（合并）**：将实例化策略信息（如 `factoryBeanName`、`factoryMethodName`）内嵌到 `BeanDefinition` 中。

**选择：合并到 BeanDefinition**

`BeanDefinition` 是不可变的元数据描述，Bean 一旦注册，其实例化方式不应改变。将策略内嵌到 `BeanDefinition` 中，使元数据自包含且完整，无需额外查找策略对象。独立接口增加了间接层，在策略固定后并不带来额外价值，反而增加了 API 的复杂性。

**新约束**：实例化策略通过 `wither` 方法调用时，每次都返回新的不可变实例，修改策略需要重新注册 `BeanDefinition`。

---

### 权衡 8：拦截器介入时机 — 尽可能早 vs 限制在特定阶段

**选项 A（尽可能早）**：拦截器从 `beforeInstantiation` 阶段开始就可以介入，甚至可以完全替代实例化。  
**选项 B（限制阶段）**：拦截器只能在初始化完成后介入，不允许干预实例化。

**选择：尽可能早**

拦截器的职责是**增强**，越早介入意味着越大的灵活性。允许 `beforeInstantiation` 短路实例化流程，使框架可以支持 Mock 注入、代理对象替换等高级特性，而无需修改框架内核。AOP 代理通常在 `afterInitialization` 阶段创建，但某些场景（如测试桩）需要在实例化前就完全替换对象。

**边界条件**：短路实例化的拦截器需要保证返回值符合 Bean 类型约束，框架不做类型校验，由拦截器实现者负责。

---

## 第五部分：应用规范与最佳实践

### `@Capper` 使用规范

#### 类注解和方法注解的职责分离

- **类注解**：声明"这个类本身是一个 Bean"，适用于可直接实例化的组件类（Service、Repository 等）。框架将通过该类的构造函数创建实例。
- **方法注解**：声明"这个方法的返回值是一个 Bean"，适用于需要通过工厂逻辑创建的对象，尤其是第三方库对象（如 `DataSource`、`RestTemplate`）或需要复杂初始化的对象。

两者语义不同，不应混用：一个类不应该同时作为自身 Bean（类注解）和工厂类（含方法注解）的唯一注册来源，尽管框架允许这种用法。

#### `names` 属性的正确使用方式

```java
// ✅ 推荐：遵循约定时，不需要指定 names
@Capper
public class UserService { ... }

// ✅ 正确：需要指定名称或别名时
@Capper(names = {"primaryDataSource", "ds"})
@Capper
public DataSource createDataSource() { ... }

// ❌ 避免：names 中包含空字符串（无意义）
@Capper(names = {""})
public class UserService { ... }
```

#### 何时使用别名

当同一 Bean 需要在多个上下文中以不同名称引用时，使用别名：
- 兼容遗留代码中使用的旧名称
- 提供更短或更具业务语义的替代名称
- 在测试环境中为 Bean 提供易于识别的名称

---

### 参数注入最佳实践

#### 何时使用 `@Inject`

```java
// ✅ 必须使用：同一接口有多个实现时，指定精确的 Bean 名称
@Capper
public class OrderService {
    @Inject  // 标记构造函数（多构造函数时必须）
    public OrderService(@Inject(beanName = "primaryDataSource") DataSource ds) { ... }
}

// ✅ 不需要使用：Bean 名称遵循约定（类型名首字母小写）
@Capper
public class ProductService {
    public ProductService(UserService userService) { ... }
    // 推导结果：注入名为 "userService" 的 Bean
}
```

#### 参数推导的最佳命名约定

为了让框架能够自动推导参数对应的 Bean，应遵循以下约定：
- Bean 名称使用类型名称首字母小写形式（如 `UserService` 类对应 Bean 名称 `userService`）
- 避免在 `@Capper.names` 中使用与类型名无关的名称，否则使用该 Bean 的构造函数需要显式 `@Inject`

#### 避免参数推导失败的方法

- 为同一接口的多个实现指定不同的 `@Capper.names`
- 在使用这些实现的构造函数/工厂方法参数上，使用 `@Inject(beanName="...")` 明确指定

---

### 内部类处理方案

#### 为什么禁止非静态内部类直接注册

非静态内部类的构造函数包含一个隐含的外部类实例参数（编译器生成），框架无法在不感知 Java 实现细节的前提下处理这一参数，且该参数不代表任何 Bean 依赖，强行处理会使参数注入语义混乱。

#### 工厂方法替代方案

```java
// ❌ 不支持：非静态内部类直接注册
@Capper
public class OuterBean {
    @Capper  // 错误用法
    public class InnerService { ... }
}

// ✅ 正确：通过外部类的工厂方法注册内部类实例
@Capper
public class OuterBean {
    @Capper
    public InnerService createInnerService() {
        return new InnerService();
    }
    public class InnerService { ... }
}
```

通过工厂方法，外部类实例作为工厂 Bean 被管理，内部类的创建由工厂方法控制，语义清晰且符合框架的实例化规范。

---

## 第六部分：可扩展性设计

### 拦截器扩展机制的规范

Cap Framework 通过 `BeanInterceptor` 提供 Bean 创建流程各阶段的扩展点：

| 拦截点 | 职责 | 短路能力 |
|--------|------|---------|
| `beforeInstantiation` | 在实例化前介入，可完全替代实例化 | ✅ 返回非 null 则短路实例化 |
| `afterInstantiation` | 实例化完成后，可对原始对象进行包装 | ❌ |
| `afterPropertyInjection` | 属性注入完成后（构造函数注入不触发此阶段） | ❌ |
| `beforeInitialization` | 初始化前，可修改对象状态 | ❌ |
| `afterInitialization` | 初始化后，AOP 代理创建的标准时机 | ❌ |

**执行顺序规范**：拦截器按 `getOrder()` 返回值**升序**执行（数字越小越先执行）。每个拦截器的返回值作为下一个拦截器的输入（链式传递）。

**拦截器可以修改的内容**：拦截器可以替换返回对象（如返回代理对象），但不应修改 `BeanDefinition`（它是不可变的）。

### 参数解析扩展的可能性

当前参数推导逻辑封装在 `BeanNamesResolver` 中。若需支持自定义推导规则（如支持 `@Qualifier` 注解的参数推导），可通过扩展 `BeanDefinitionRegisterBootstrapRunner` 或在注册阶段前后插入自定义的 `BootstrapRunner`（通过 `@RunnerMeta.order` 控制执行顺序）。

自定义推导规则应遵循以下约定：
- 推导失败时抛出 `BeanDefinitionException`，而非静默返回 null
- 推导结果应与容器中已注册的 Bean 名称对应，避免在运行时产生 `NoSuchBeanDefinitionException`

### 容器实现的可替换性

自定义容器实现需满足以下接口：
- `BeanContainer`：整合注册、查询、创建三大能力的完整容器接口
- `BeanRegistry`：Bean 定义和别名的注册与移除
- `BeanProvider`：按名称/类型获取 Bean 实例
- `BeanInspector`：容器结构的只读查询

实现自定义容器时必须保证：
- 注册阶段的约束校验（同名 Bean 不允许覆盖、`BeanDefinition` 字段约束）
- 单例的线程安全创建（首次 `getBean` 时的并发安全）
- 销毁阶段的逆序执行语义

---

## 第七部分：约束与边界条件

### 明确不支持的场景

#### 非静态内部类直接标注 `@Capper`

框架不支持扫描和注册非静态内部类的 `@Capper` 注解。如需将非静态内部类的实例纳入容器管理，必须使用外部类中的工厂方法。

#### 循环依赖

框架不支持构造函数循环依赖（Bean A 的构造函数依赖 Bean B，Bean B 的构造函数依赖 Bean A）。这类循环在实例化阶段会导致无限递归，框架不提供特殊处理机制。规范层面的建议：循环依赖通常是设计问题的信号，应通过重构消除，而非依赖框架的循环依赖解析（该机制会引入复杂性和隐患）。

#### 参数无法推导的构造函数

若构造函数的某个参数类型没有简单类名（如匿名类），且未标注 `@Inject(beanName="...")`，则该参数无法推导 Bean 名称，框架将在注册阶段抛出 `BeanDefinitionException`。

---

### 模糊边界的澄清

#### Bean 名称重复时的处理规范

同一名称（无论是主名称还是别名）只能指向一个 Bean。若尝试注册与已有 Bean 主名称相同的新 Bean，抛出 `BeanDefinitionStoreException`。若别名与已有 Bean 的主名称或别名冲突，同样抛出异常。框架不支持 Bean 覆盖，需要替换时应先移除。

#### 工厂方法返回类型与 Bean 类型的关系

工厂方法的返回类型即为 Bean 的类型（`BeanDefinition.type()`）。框架不验证返回类型的子类型关系，`getBeansOfType()` 基于 `BeanDefinition.type()` 进行类型匹配，而非运行时实例的实际类型。

#### `@Capper` 方法所在类未标注 `@Capper` 时的规范

即使工厂方法所在类未标注 `@Capper`，框架依然会将该类自动注册为 Bean（以类名首字母小写作为 Bean 名称）。这是必要的——非静态工厂方法需要一个工厂 Bean 实例才能被调用。若不希望工厂类被作为 Bean 暴露，可将工厂方法声明为静态方法。

---

## 第八部分：框架演进方向

Cap Framework 的当前设计在多个维度上预留了演进空间，不会因为今天的决策而堵塞未来的改进路径。

### 参数注入的灵活性扩展

当前的三级参数推导优先级（`@Inject` > 类型名称 > 抛出异常）是一个有序且可扩展的模型。未来可以在现有优先级体系中插入新的推导规则（如基于 `@Qualifier` 的推导、基于参数名称反射的推导）而无需重构现有逻辑。`BeanNamesResolver` 的接口设计使得推导逻辑可以独立演进，不影响容器核心。

### 拦截器机制的富化

`BeanInterceptor` 接口覆盖了 Bean 创建流程的所有关键节点。随着框架使用场景的丰富，可以在不修改接口的前提下：
- 引入拦截器分组和条件激活（如仅对特定类型生效）
- 支持拦截器链的动态调整（运行时注册/注销）
- 为特定阶段引入专用的拦截器接口（如 `InstantiationAwareInterceptor`）

这些扩展均在现有抽象之上叠加，不破坏已有拦截器实现的兼容性。

### 实例化策略的演进

当前将实例化策略内嵌到 `BeanDefinition` 的设计保证了元数据自包含。若未来需要支持更多实例化策略（如从 `Supplier<T>` 创建、从序列化恢复），可以在 `BeanDefinition` 中引入一个枚举类型的策略标识符，无需改变现有的 `factoryBeanName` / `factoryMethodName` 语义。不可变记录的设计使扩展字段不会影响已有实例的行为。

### 容器实现的多样化

`BeanContainer` 接口的设计使框架上层（`cap-boot`、`cap-core`）完全面向接口编程，不依赖具体实现。这为未来引入集群感知容器、延迟加载容器、只读快照容器等变体奠定了基础，同时保证现有业务代码无需修改。
